# Односвязный список
## Теория связного списка
### Что такое связный список?

**Связный список** — это структура данных, состоящая из элементов (узлов), которые хранят данные и ссылку на следующий элемент. Каждый элемент "связан" с последующим, отсюда и название — связный список.

#### Основные понятия:

1. **Узел (Node)** — основной элемент связного списка. Он содержит:
    - **Данные (data)** — информация, которую мы храним (число, строка, объект и т.д.).
    - **Ссылка на следующий узел (next)** — указатель на следующий узел в списке.
2. **Голова (head)** — это первый элемент списка. Через голову можно получить доступ ко всем остальным узлам.
3. **Последний узел** — это узел, чей указатель `next` равен `None`, что означает конец списка.

### Основные операции:

1. **Добавление элемента** — элемент можно добавлять в конец списка, в начало или в любое другое место. Для добавления в конец, нужно пройти по всему списку до последнего узла, а затем присоединить новый элемент.
    
2. **Удаление элемента** — удаление узла по индексу или значению. Если удаляется первый узел (голова), голова сдвигается на следующий элемент.
    
3. **Поиск элемента** — для поиска элемента нужно пройти по узлам, начиная с головы, пока не будет найден нужный элемент или пока список не закончится.
    
4. **Обращение по индексу** — в отличие от массивов (списков Python), к элементу связного списка нельзя обратиться напрямую через индекс. Нужно пройти по узлам один за другим до нужного индекса.
    

### Типы связных списков:

1. **Односвязный список** — самый простой вариант, где каждый узел содержит ссылку только на следующий узел.
2. **Двусвязный список** — здесь каждый узел содержит ссылки на следующий и предыдущий узлы, что позволяет двигаться в обе стороны по списку.
3. **Кольцевой связный список** — в этом списке последний узел указывает на первый узел, создавая круг.

### Преимущества связных списков:

1. **Динамическое изменение размера** — в отличие от массивов, которые имеют фиксированный размер, связные списки могут расширяться и сжиматься по мере добавления и удаления элементов.
2. **Эффективное добавление/удаление** — добавление или удаление элементов происходит быстро, особенно если известно, где находится нужный узел.

### Недостатки связных списков:

1. **Медленный доступ по индексу** — чтобы получить элемент по индексу, нужно пройти по каждому узлу, начиная с головы.
2. **Дополнительная память** — каждый узел хранит не только данные, но и ссылку на следующий узел, что требует дополнительной памяти.

### Свойства связного списка:

- **Длина** — это количество узлов в списке.
- **Гибкость** — можно легко изменить структуру списка, добавляя или удаляя элементы.
- **Последовательный доступ** — все элементы связаны последовательно, и для доступа к каждому элементу нужно идти от начала.

### Когда использовать связный список:

- Когда вам нужно часто добавлять и удалять элементы.
- Когда нужно управлять динамическими структурами данных, которые могут изменяться по размеру.

## Реализация односвязного списка:
```Python
class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    # Метод для добавления элемента в конец списка
    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node

    # Магический метод для представления списка в виде строки
    def __repr__(self):
        nodes = []
        current_node = self.head
        while current_node:
            nodes.append(repr(current_node.data))
            current_node = current_node.next
        return " -> ".join(nodes)

    # Магический метод для получения длины списка через len()
    def __len__(self):
        count = 0
        current_node = self.head
        while current_node:
            count += 1
            current_node = current_node.next
        return count

    # Метод для вставки элемента на определённую позицию
    def insert(self, index, data):
        new_node = Node(data)
        if index == 0:
            new_node.next = self.head
            self.head = new_node
            return
        current_node = self.head
        current_index = 0
        while current_node and current_index < index - 1:
            current_node = current_node.next
            current_index += 1
        if current_node is None:
            raise IndexError("Index out of range")
        new_node.next = current_node.next
        current_node.next = new_node

    # Метод для удаления элемента по индексу
    def delete(self, index):
        if self.head is None:
            raise IndexError("Delete from empty list")
        if index == 0:
            self.head = self.head.next
            return
        current_node = self.head
        current_index = 0
        while current_node and current_index < index - 1:
            current_node = current_node.next
            current_index += 1
        if current_node is None or current_node.next is None:
            raise IndexError("Index out of range")
        current_node.next = current_node.next.next

    # Магический метод для обращения по индексу через квадратные скобки
    def __getitem__(self, index):
        current_node = self.head
        current_index = 0
        while current_node:
            if current_index == index:
                return current_node.data
            current_node = current_node.next
            current_index += 1
        raise IndexError("Index out of range")

    # Магический метод для изменения значения по индексу
    def __setitem__(self, index, data):
        current_node = self.head
        current_index = 0
        while current_node:
            if current_index == index:
                current_node.data = data
                return
            current_node = current_node.next
            current_index += 1
        raise IndexError("Index out of range")

# Примеры использования

# Создание списка и добавление элементов
ll = LinkedList()
ll.append(1)
ll.append(2)
ll.append(3)
print(f"Список после добавления элементов: {ll}")

# Вставка элемента на определенную позицию
ll.insert(1, 1.5)
print(f"Список после вставки элемента на позицию 1: {ll}")

# Получение элемента по индексу
print(f"Элемент на позиции 2: {ll[2]}")

# Изменение элемента по индексу
ll[2] = 2.5
print(f"Список после изменения элемента на позиции 2: {ll}")

# Удаление элемента по индексу
ll.delete(1)
print(f"Список после удаления элемента на позиции 1: {ll}")

# Вывод длины списка
print(f"Длина списка: {len(ll)}")
```

## Рассмотрение основных частей кода
### 1. Класс Node
```Python
# Класс, представляющий один узел в односвязном списке
class Node:
    # Конструктор, который инициализирует узел данными и ссылкой на следующий узел
    def __init__(self, data=None):
        # Данные, хранимые в узле
        self.data = data
        # Ссылка на следующий узел, по умолчанию None (так как узел последний)
        self.next = None
```
#### Описание:

- Класс `Node` представляет собой узел односвязного списка.
- Каждый узел содержит данные (`data`) и ссылку на следующий узел (`next`).
- Конструктор принимает данные в качестве аргумента и по умолчанию делает ссылку на следующий узел равной `None`.

#### Конкретные детали:

- **`self.data`**: хранит данные узла (например, число, строку или любой другой объект).
- **`self.next`**: указывает на следующий узел в списке или остается `None`, если узел последний.

### 2. Класс LinkedList
```Python
# Класс, представляющий односвязный список
class LinkedList:
    # Конструктор, который инициализирует список, задавая указатель на первый элемент (head) как None
    def __init__(self):
        # Начало списка (голова), изначально список пуст
        self.head = None
```

#### Описание:

- Класс `LinkedList` представляет собой сам односвязный список.
- Он содержит только один атрибут `head`, который является указателем на первый узел списка. Изначально `head` равен `None`, что означает, что список пуст.

#### Конкретные детали:

- **`self.head`**: указатель на первый элемент списка. Через него можно получить доступ ко всем узлам списка.

### 3. Метод append
```Python
    # Метод для добавления элемента в конец списка
    def append(self, data):
        # Создаем новый узел с переданными данными
        new_node = Node(data)
        # Если список пуст (head равен None), новый узел становится первым элементом списка
        if self.head is None:
            self.head = new_node
            return
        # Иначе находим последний узел списка
        last_node = self.head
        # Проходим по списку, пока не найдем последний узел (где next равен None)
        while last_node.next:
            last_node = last_node.next
        # Устанавливаем новый узел как следующий для последнего узла
        last_node.next = new_node
```

#### Описание:

- Метод `append` добавляет новый элемент в конец списка.
- Создается новый узел с данными. Если список пуст (голова равна `None`), новый узел становится первым узлом. Иначе происходит поиск последнего узла, после которого добавляется новый.

#### Конкретные детали:

- **`while last_node.next`**: цикл, который проходит по узлам списка, пока не достигнут последний узел.
- **`last_node.next = new_node`**: устанавливает новый узел как следующий для последнего узла.

### 4. Магический метод \_\_repr\_\_
```Python
    # Метод для строкового представления списка
    def __repr__(self):
        # Список для хранения строкового представления узлов
        nodes = []
        # Начинаем с головы списка
        current_node = self.head
        # Проходим по всем узлам списка
        while current_node:
            # Добавляем строковое представление данных текущего узла в список
            nodes.append(repr(current_node.data))
            # Переходим к следующему узлу
            current_node = current_node.next
        # Возвращаем строку, представляющую узлы, соединенные через ' -> '
        return " -> ".join(nodes)
```

#### Описание:

- Этот магический метод определяет, как объект списка будет представлен в виде строки.
- Проходит по всем узлам, добавляя их данные в список, и возвращает строку, где узлы разделены символом `->`.

#### Конкретные детали:

- **`repr(current_node.data)`**: преобразует данные узла в строковое представление.
- **`" -> ".join(nodes)`**: создает строку с элементами, разделенными символом "->", показывая порядок узлов в списке.

### 5. Магический метод \_\_len\_\_
```Python
    # Метод для получения длины списка (возвращает количество узлов)
    def __len__(self):
        # Счетчик узлов
        count = 0
        # Начинаем с головы списка
        current_node = self.head
        # Проходим по узлам списка, увеличивая счетчик на каждом шаге
        while current_node:
            count += 1
            # Переход к следующему узлу
            current_node = current_node.next
        # Возвращаем общее количество узлов
        return count
```

#### Описание:

- Этот магический метод возвращает длину списка (количество узлов).
- Проходит по всем узлам списка и считает их количество.

#### Конкретные детали:

- **`count`**: счетчик количества узлов.
- **`current_node = current_node.next`**: переход к следующему узлу в списке.

### 6. Метод insert
```Python
def insert(self, index, data):
        # Метод для вставки нового узла на заданную позицию
    def insert(self, index, data):
        # Создаем новый узел с переданными данными
        new_node = Node(data)
        # Если вставляем в начало списка (index == 0)
        if index == 0:
            # Новый узел становится головой, а его next указывает на старую голову
            new_node.next = self.head
            self.head = new_node
            return
        # Начинаем с головы списка
        current_node = self.head
        # Текущий индекс
        current_index = 0
        # Проходим по списку, пока не достигнем нужного индекса или конца списка
        while current_node and current_index < index - 1:
            current_node = current_node.next
            current_index += 1
        # Если индекс выходит за пределы списка, выбрасываем исключение
        if current_node is None:
            raise IndexError("Index out of range")
        # Вставляем новый узел, ссылающийся на следующий узел текущего
        new_node.next = current_node.next
        # Обновляем ссылку текущего узла на новый узел
        current_node.next = new_node
```

#### Описание:

- Метод вставляет новый узел на заданную позицию `index`.
- Если индекс равен 0, узел вставляется в начало списка. Если индекс больше 0, происходит поиск узла перед позицией вставки, и новый узел вставляется после него.

#### Конкретные детали:

- **`index == 0`**: обработка специального случая, когда узел вставляется в начало списка.
- **`raise IndexError("Index out of range")`**: выбрасывает исключение, если индекс за пределами списка.

### 7. Метод delete
```Python
    # Метод для удаления узла на заданной позиции
    def delete(self, index):
        # Если список пуст, выбрасываем исключение
        if self.head is None:
            raise IndexError("Delete from empty list")
        # Если нужно удалить первый узел (head)
        if index == 0:
            # Голова сдвигается на следующий узел
            self.head = self.head.next
            return
        # Начинаем с головы списка
        current_node = self.head
        # Текущий индекс
        current_index = 0
        # Проходим по узлам, пока не достигнем узла перед удаляемым
        while current_node and current_index < index - 1:
            current_node = current_node.next
            current_index += 1
        # Если индекс выходит за пределы списка, выбрасываем исключение
        if current_node is None or current_node.next is None:
            raise IndexError("Index out of range")
        # Перенаправляем ссылку узла на следующий за удаляемым узел
        current_node.next = current_node.next.next
```

#### Описание:

- Метод удаляет узел на позиции `index`.
- Если индекс равен 0, удаляется первый узел. Для других индексов находится узел перед удаляемым, и его ссылка изменяется на узел, следующий за удаляемым.

#### Конкретные детали:

- **`self.head = self.head.next`**: удаление первого узла, сдвиг головы списка.
- **`raise IndexError("Index out of range")`**: обработка попытки удаления по несуществующему индексу.

### 8. Магический метод \_\_getitem\_\_
```Python
    # Метод для получения элемента по индексу через квадратные скобки
    def __getitem__(self, index):
        # Начинаем с головы списка
        current_node = self.head
        # Текущий индекс
        current_index = 0
        # Проходим по узлам, пока не достигнем нужного индекса
        while current_node:
            # Если текущий индекс совпадает с запрашиваемым, возвращаем данные узла
            if current_index == index:
                return current_node.data
            # Переход к следующему узлу
            current_node = current_node.next
            current_index += 1
        # Если индекс выходит за пределы списка, выбрасываем исключение
        raise IndexError("Index out of range")
```

#### Описание:

- Магический метод позволяет обращаться к элементам списка через индекс (как с обычным списком).
- Проходит по узлам до достижения нужного индекса, после чего возвращает данные узла.

#### Конкретные детали:

- **`raise IndexError("Index out of range")`**: выбрасывается, если индекс выходит за пределы списка.

### 9. Магический метод \_\_setitem\_\_
```Python
    # Метод для изменения значения элемента по индексу через квадратные скобки
    def __setitem__(self, index, data):
        # Начинаем с головы списка
        current_node = self.head
        # Текущий индекс
        current_index = 0
        # Проходим по узлам, пока не достигнем нужного индекса
        while current_node:
            # Если текущий индекс совпадает с запрашиваемым, изменяем данные узла
            if current_index == index:
                current_node.data = data
                return
            # Переход к следующему узлу
            current_node = current_node.next
            current_index += 1
        # Если индекс выходит за пределы списка, выбрасываем исключение
        raise IndexError("Index out of range")
```

#### Описание:

- Магический метод для изменения значения элемента по индексу.
- Проходит по списку до нужного индекса и заменяет данные узла новыми.

#### Конкретные детали:

- **`current_node.data = data`**: присвоение нового значения узлу на указанной позиции.

