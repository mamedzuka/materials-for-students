### Стандартные коллекции 
К стандартным отнесем следующие коллекции:
1. ***Список*** или **List**
2. ***Кортеж*** или **Tuple**
3. ***Множество*** или **Set**
4. ***Хэш-таблицу*** или ***Словарь*** или **Map**

#### List - список
###### Определения
> [!note] Определение
**Список** - это упорядоченная изменяемая коллекция объектов произвольных типов. Список может быть представлен как `[ ]`.

Для понимания того, что такое *список* важно понимать, что такое *массив* и видеть в этих структурах данных различия.
> [!note] Определение
**Массив** - это упорядоченная изменяемая коллекция объектов одного типа данных.

В итоге видим, что основное отличие между **массивом** (*мы говорим об изменяемом в том числе по объему динамическом массиве*) и **списком** - это возможность списка хранить объекты разных типов. 
На самом деле же список в питоне - это тоже *динамический массив*, просто так как все типы данных в питоне наследуются от общего прародителя **Object**, то хранящий ***указатели на Object*** динамический массив становится списком.

###### Свойства
1. Список допускает дублирование элементов
2. Список изменчив, т.е. программист можем вносить любые изменения в список по ходу исполнения программы (**runtime**)
3. Список упорядочен
4. Список может хранить любые объекты

###### Примеры списков
```Python	
[1, 2, 3, 4, 5, 6] - список целочисленных значений
["привет", "пока", "попа", "биба", "шлепа"] - список строк
[1 < 3, 2 and 3, 2 != 'попка'] - список логических выражений 
# [True, True, True]
[ [ 1, 3, 5],
  ["попка", "бибка", "шлепка"], 
  [1 < 3, 2 and 3, 2 != 'попка']] - список списков
["попка", 123, [132, [23, 14]]] - список различных объектов
[] - пустой список - может являться также значением, типа False
```

###### Работа со списками
- Создание
```Python 
# через []
a = [1, 2, 3, 4, 5]
a = [] - создание пустого списка

# через конструктор класса list()
a = list("список") # a == ["c", "п", "и", "с", "о", "к"] 
a = list([1])
a = list(range(0, 10)) # a == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# через списковое включение
a = [i for i in range(0, 10)] 
range дает нам интервал - [0, 10)
Итоговый список - [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9] === a

```

Общий вид спискового включения:
```Python
a = [<1> for <2> in <3> if <4>]

<1> - выражение для элементов списка
<2> - элемент эталонного списка, н-р: i
<3> - итерируемый объект, на основе которого строим новый список
<4> - условие, проверяющее элемент списка, на основе которого строим список. При выполнении условия выполняется <1>

# Цикл, который списковое включение заменяет
a = []
for i in range(0, 10): 
	if i % 2 == 0: 
		a += [i**2]
```

- Получение элемента:
```Python
# по индексу
a = [1, 2, 3, 4, 5]
a[0] == 1
a[-1] == 5

# по интервалу (срезу)
a[start:end] == [от start до end] - общий вид среза (start < end)

a = [1, 2, 3, 4, 5]
a[:] == [1, 2, 3, 4, 5]
a[:2] == [1, 2]
a[2:] == [3, 4, 5]
a[2:4] == [3, 4] == a[-3:-1]
a[-1:-3] == [] == a[2:1]

# по интервалу с шагом (двойному срезу) 
a[start:end:step] == [от start до end с шагом step] - общий вид двойного среза

a = [1, 2, 3, 4, 5]	
a[::] == [1, 2, 3, 4, 5]
a[::-1] == [5, 4, 3, 2, 1]
a[::2] == [1, 3, 5]
```

- Добавление элемента в список:
```Python
# добваление нового элемента в список
a = [1, 2, 3]
a.append("строка") # a == [1, 2, 3, "строка"]
```

- Изменение элементов списка:
```Python
# изменение элемента по индексу
a = [1, 2, 3, 4, 5]
a[0] = 3 # a == [3, 2, 3, 4, 5]
```

- Сложение, умножение списков
```Python
# изменение списка посредством конкатенации (сложения) двух и более списков
a = [1, 2, 3, 4, 5]
a = a + [2] или a += [2] # a == [1, 2, 3, 4, 5, 2] 
a = a + a или a += a # a == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]

# изменение списка посредством умножения списка на число
a = [1, 2, 3, 4, 5]
a = a * 3 или a \*= 3 # a == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
```

---

#### Tuple - кортеж
###### Определения
> [!note] Определение
**Кортеж** - это упорядоченная неизменяемая коллекция объектов произвольных типов. Кортеж может быть представлен как `()`.

###### Свойства
1. Кортеж допускает дублирование элементов
2. Кортеж неизменяем, т.е. мы можем вносить любые изменения в список
3. Кортеж упорядочен
4. Кортеж может хранить любые объекты

###### Примеры кортежей 
```Python	
(1, 2, 3, 4, 5, 6) - кортеж целочисленных значений
("привет", "пока", "попа", "биба", "шлепа") - кортеж строк
(1 < 3, 2 and 3, 2 != 'попка') - кортеж логических выражений 
("попка", 123, [132, (23, 14)]) - кортеж различных объектов
() - пустой кортеж - может являться также значением, типа False
```

###### Работа с кортежами
Аналогична спискам, но `[]` заменяется на `()`, `list()` на `tuple()`, изменять элементы внутри кортежа попросту нельзя, ровно как и добавлять новые элементы в кортеж, но складывать, умножать кортежи для создания новых кортежей вполне можно.

---

#### Хэш-таблица - map
###### Определения
> [!note] Определение
**Словарь** или **Хэш-таблица**- неупорядоченная изменяемая коллекция объектов произвольных типов, состоящая из *пар объектов ключ-значение*. Хэш-таблица может быть представлена
 как `{}`.

***Важный момент***: по сути, **словарь** - это ***структура данных***, синоним которому *ассоциативный массив*, а вот **хеш-таблица** - это ***вариант реализации*** словаря.

###### Свойства
1. Словарь не допускает дублирование ключей, но допускает дублирование значений элементов
2. Словарь изменяем, т.е. мы можем вносить любые изменения в словарь, но не дублировать ключи элементов
3. Словарь не упорядочен
4. Словарь может хранить любые объекты в качестве значений
5. Словарь может хранить строки, кортежи, целые числа, числа с плавающей запятой, булевые константы в качестве ключей (`int, float, bool, string, tuple`) - неизменяемые (**immutable**) объекты

###### Примеры словарей 
```Python	
{"key": 1, "ключ": 2} - словарь пар строка-целое число
{("key", 123): 1, "ключ": 2} - словарь с кортежем в качестве ключа
{} - пустой словарь - может являться также значением, типа False
```

###### Работа со словарями
- Создание
```Python 
# через {}
a = {
	"numbers": `[2, 3, 4, 5]`,
	"name": "Имя",
	"gender": "ж"
}
a = {} - создание пустого списка

# через конструктор класса dict()
a = dict(name = "Имя", age = 17, gender = "male") 
# a == {"name": "Имя", "age": 17, "gender": "male")}

# через словарное включение
a = {i:i for i in range(0, 10)} 
range дает нам интервал - [0, 10)
Итоговый словарь - {0: 0, 1: 1, 2: 2, ..., 9: 9} === a
```

Общий вид словарного включения:
```Python
a = {<1>:<1> for <2> in <3> if <4>}

<1>:<1> - выражение для пар ключ:значение словаря - key:value
<2> - элемент эталонного итерируемого объекта, н-р: i
<3> - итерируемый объект, на основе которого строим новый словарь
<4> - условие, проверяющее элемент списка, на основе которого строим словарь. 
При выполнении условия выполняется <1>:<1>

# Цикл, который списковое включение может заменить
a = {}
for i in range(0, 10): 
	if i % 2 == 0: 
		a[i] = i
```

- Получение элементов:
```Python
# одного по индексу
a = {
	"numbers": [2, 3, 4, 5],
	"name": "Имя",
	"gender": "ж"
}
a["numbers"] == [2, 3, 4, 5]

# списка всех ключей
a = {
	"numbers": [2, 3, 4, 5],
	"name": "Имя",
	"gender": "ж"
}
a.keys() == ["numbers", "name", "gender"]

# списка всех значений
a = {
	"numbers": [2, 3, 4, 5],
	"name": "Имя",
	"gender": "ж"
}
a.values() == [[2, 3, 4, 5], "Имя", "ж"]

# списка всех пар ключ:значение
a = {
	"numbers": [2, 3, 4, 5],
	"name": "Имя",
	"gender": "ж"
}
a.items() == [(numbers", [2, 3, 4, 5]), ("name", "Имя"), ("gender", "ж")]
```

- Добавление элемента:
```Python
# добавление нового элемента в список по индексу
a = {
	"numbers": [2, 3, 4, 5],
	"name": "Имя",
	"gender": "ж"
}
a["hair_color"] = "red"
```

- Изменение элементов:
```Python
# изменение элемента по индексу
a = {
	"numbers": [2, 3, 4, 5],
	"name": "Имя",
	"gender": "ж"
}
a["gender"] = "м"
```

---

#### Множество - set
###### Определения
> [!note] Определение
**Множество** - неупорядоченная изменяемая (не по элементам, а по объему) коллекция объектов произвольных типов. Множество может быть представлено как `{ }`.

###### Свойства
1. Множество не допускает дублирование элементов
2. Множество изменяемо, т.е. мы можем вносить любые изменения в множество, но не дублировать элементы или заменять старые элементы на новые (по крайней мере так, как это делается в списках, кортежах и словарях)
3. Множество не упорядочено
4. Множество может хранить любые объекты

###### Пример множества
```Python	
{"key", 2, (1, 3)} - сножество из различных элементов
Пустого множества нет
```

###### Работа с множествами (ДЗ)
> [!Note] Суть домашки
> Найти по следующему плану функции, при помощи которых можно работать с множествами и записать

- Создание (не забыть про **множественное включение** - аналог спискового включения (проще искать как **set comprehasion**))
- Получение элементов (подсказка - используем **методы** множества)
- Добавление элементов

---
### Импортируемые коллекции
К импортируемым коллекциям отнесем:
1. ***Двухсторонняя очередь*** или **deque** из пакета *collections*
2. ***Динамический массив*** или **array** из пакета *arrays*

#### Deque - двухсторонняя очередь
###### Определения
> [!note] Определение
**Двустороння очередь** - это упорядоченная изменяемая коллекция объектов произвольных типов, которая может добавлять и извлекать элементы как из своего начала, так и из своего конца, а также доступаться к элементам по их индексам.

На основе **deque** в Python могут быть реализованы две другие важные и часто используемые структуры данных - `queue` или очередь и `stack` или стэк. 

###### Свойства
1. Двустороння очередь допускает дублирование элементов
2. Двустороння очередь изменчива, т.е. программист можем вносить в нее любые изменения по ходу исполнения программы (**runtime**)
3. Двустороння очередь упорядочена
4. Двустороння очередь может хранить любые объекты

###### Пример двусторонней очереди
```Python	
from collections import deque

d = deque(["опа", 1, [1, 2, 3]]) - данная дэка будет содержать 3 элемента
```

###### Работа с дэками
- Создание
```Python
# создание дэки через конструктор
from collections import deque

d = deque([1, 2, "str", (1, 2.3, 4)]) [out]: deque([1, 2, "str", (1, 2.3, 4)])
```
Дэка создается на основе **Iterable** (итерируемого) объекта

- Добавление элементов
```Python
from collections import deque

d = deque([1, 2, 3]) 

# добавление элемента в конец (справа)
d.append('j') [out]: deque([1, 2, 3, 'j'])

# добавление элемента в начало (слева)
d.appendleft('a') [out]: deque(['a', 1, 2, 3, 'j'])

# добавление множества элементов в конец
d.extend([1, 3, 5]) [out]: deque(['a', 1, 2, 3, 'j', 1, 3, 5])

# добавление множества элементов в начало
d.extendleft([1, 3, 5]) [out]: deque([ 1, 3, 5, 'a', 1, 2, 3, 'j', 1, 3, 5])
```

- Получение элементов
```Python
from collections import deque

d = deque([1, 2, 3]) 

# методы pop - получение элемента с одновременным удалением из дэки
d.pop() [out]: 3

d.popleft() [out]: 1

print(d) [out]: deque([2])

# получение элемента по индексу
d = deque([1, 2, 3]) 

d[0] [out]: 1
d[2] [out]: 3
d[-1] [out]: 3
```

- Дополнительные методы
```Python
from collections import deque

d = deque([1, 2, 3]) 

# переставить элементы дэки (с конца в начало)
d.rotate(1) [out]: deque([3, 1, 2])

# переставить элементы дэки (с начала в конец)
d.rotate(-2) [out]: deque([2, 3, 1])

# очищение дэки
d.clear() [out]: deque([])

# преведение к списку
list(d) [out]: []
```

###### Реализация очереди на основе дэки
Очередь - это структура данных, для которой основным правилом взаимодействия с элементами является ***First-in-First-out*** - **Первый вошел, первый вышел**
```Python
from collections import deque

class Queue:
    def __init__(self):
        self._elems = deque()

    def append(self, item):
        self._elems.append(item)

    def pop(self):
        try:
            return self._elems.popleft()
        except IndexError:
            raise IndexError("dequeue from an empty queue") from None

    def __len__(self):
        return len(self._elems)

    def __repr__(self):
        return f"Queue({list(self._elems)})"
```


#### ДЗ - реализовать аналогично очереди СТЭК

---