### Теория
#### Блок-схемы
##### Основные элементы блок-схем:
1. **Терминатор (Овал)**:
	- **Назначение**: Начало и конец алгоритма.
    - **Пример**: "Начало" или "Конец".
    - Используется для обозначения точек, с которых начинается и завершается выполнение алгоритма.
    -  ![[Pasted image 20240908193031.png]]

2. **Процесс (Прямоугольник)**:
    - **Назначение**: Выполнение действий или операций.
    - **Пример**: "X = X + 1".
    - Представляет вычислительные операции, такие как присваивание значений, математические действия.
    -  ![[Pasted image 20240908193007.png]]

3. **Условие (Ромб)**:
    - **Назначение**: Проверка условий, которые приводят к ветвлению алгоритма (ветви "да" и "нет").
    - **Пример**: "X > 10?".
    - Используется для принятия решений, что в алгоритме будет выполнено в зависимости от условия.
	-  ![[Pasted image 20240908193109.png]]

4. **Ввод/вывод (Параллелограмм)**:
    - **Назначение**: Ввод данных или вывод информации.
    - **Пример**: "Ввод X" или "Вывод Y".
    - Применяется для всех операций с внешними данными.
    - ![[Pasted image 20240908193135.png]] 

5. **Предопределённый процесс (Прямоугольник с двойными линиями)**:
    - **Назначение**: Вызов подпрограммы или функции, которая была определена отдельно.
    - **Пример**: "Вызвать функцию `Сумма()`".
    - Упрощает схему за счёт использования подпрограмм.
    -  ![[Pasted image 20240908193416.png]]

6. **Чало и конец цикла (Прямоугольник с двойными линиями)**:
    - **Назначение**: Вызов цикла `for`.
    - Упрощает схему за счёт множественного повторения действия в цикле.
	- ![[Pasted image 20240908194448.png|150]]

7. **Стрелки (Поток управления)**:
    - **Назначение**: Обозначают направление выполнения действий в алгоритме.
    - **Пример**: Стрелка от одного блока к другому.
    - Связывают элементы и показывают, в каком порядке будет происходить выполнение алгоритма.

##### O-нотация (нотация О большое):
Эффективность алгоритма можно оценивать по-разному. В первую очередь можно просто начать считать количество выполняемых алгоритмом шагов. Но число шагов алгоритма - это чаще всего **зависимая величина** (**от числа элементов обрабатываемого алгоритма массива** данных например). Поэтому, чтобы количественно оценить эффективность такого алгоритма, мы можем сказать, что для выполнения в *массиве из N элементов нужно N шагов*.
Именно в момент осознания данной оценки эффективности в игру вступает математическая концепция **нотации О большое**. 

Итак, в случае, если мы видим запись **O(N)** - это значит что при **N** числе элементов в обрабатываемом массиве мы получим **N** шагов алгоритма.
Рассмотрим ещё варианты **O от различных N**:
- **O(1)** - это вариант, при котором для любого числа элементов алгоритм будет выполнятся за 1 шаг или, говоря правильнее, за **фиксированное время**. Таким образом, и для 1000 элементов, и для 1 элемента данный алгоритм будет работать какое-то *ограниченное константное время* (САМЫЙ БЫСТРЫЙ ВАРИАНТ)
- **O(N) == O(2N) == O(57N)** - при **N** числе элементов в обрабатываемом массиве мы получим **N** шагов алгоритма. Почему знаки равенства? Потому что в данном случае **O(N)** - это общий показатель, показывающий не точное время выполнения алгоритма, а то, как будет изменятся *время выполнения алгоритма в зависимости от объема обрабатываемых им данных*. В данном случае время изменяется **линейно**. В первом случае можно добавить, что **O(1) == O(4) == O(1000003214)** - выполняется за константное количество шагов и не меняется при изменении объема входных данных

> [!note] Ух ты как важно...
> Но разве можно говорить о том, что алгоритм со сложностью **O(1000003214)** эффективнее алгоритма со сложностью **О(N)**? Да, но стоит упомянуть, что данный алгоритм будет эффективнее в тот момент, когда *N > 1000003214*, но так как число 1000003214 - это лишь песчинка в неограниченном бесконичном море объемов данных мы в общем можем говорить, что алгоритм с константным выполнением в целом эффективнее.

- **O(*log N*)** -  сложность между **O(1)** и **O(N)**. Число шагов в таком алгоритме увеличивается **на единицу** при каждом **удвоении обьема** данных. Да, в данном случае у нас подразумевается именно **ДВОИЧНЫЙ** логарифм.
![[Pasted image 20240908202428.png]]
Есть и другие сложности, но их эти основные. Их нам пока что и хватит.

###### Примеры
Берем код на питоне:
```python
things = ['apples', 'baboons', 'cribs', 'dulcimers' ]
for thing in things :
	print ("Here's а thing: %s " %thing)
```
Сколько раз выполнится цикл? А если элементов в массиве будет 20?

Рассмотрим, каким образом будут меняться сложности (эффективности) работы программы по времени в зависимости от того, какие операторы использованы в коде:
- Условие if:
```python
if number % 2 == 0:  
	<..k..> - действия в теле if 
	
A(min для if) == 1
A(max для if) == 1 + k

O(1)
```

- Условие if-else:
```python
if number % 2 == 0:   
	<..k..> - действия в теле if 
else:
	<..m..> - действия в теле else 

A(min для if-else) == 1 + m, если m < k, или 1 + k, если k < m
A(max для if-else) == 1 + m, если m > k, или 1 + k, если k > m

O(1)
```

- Цикл for:
```python
for i in ...:
	<..k..> - действия в теле for 

A(min для for) = 0 * <..k..> = 0, где 0 - это число итераций
A(max для for) = 00 * <..k..>, где 00 - это бесконечное или очень большое число итераций

O(n) или O(log(n)) в лучшем из случаев
```

- Вложенные циклы for:
```python
for i in ...:
	for j in ...:
		<..k..> - действия в теле вложенных for 

A(min для for-for) = 0 * 0 * <..k..> = 0^2, где 0 - это число итераций в обоих циклах
A(max для for-for) = 00 * 00**<..k..> = 00^2, где 00 - это бесконечное или очень большое 
число итераций в обоих циклах

O(n^2) или O(n*log(n)) в лучшем из случаев
```

- Цикл while:
```python
while <условие>:
	<..k..>  - действия в теле вложенных while 

A(5) = (1 + k) * 5
A(10) = (1 + k) * 10

A(min для while) = 1
A(max для while) = (1 + <..k..>) * 00, где 00 - это бесконечное или очень большое число итераций, вызванных выполнением условия

O(n) или O(log(n)) в лучшем из случаев
```

##### Эффективности (сложности)
![[Pasted image 20240913122417.png]]